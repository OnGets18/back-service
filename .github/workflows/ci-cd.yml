name: CI/CD Pipeline

on:
  push:
    branches: [ main, master ]
  pull_request:
    branches: [ main, master ]

env:
  DOCKER_USERNAME: ongets18
  IMAGE_NAME: back-service

jobs:
  test:
    name: Run Tests
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '24'
          cache: 'npm'
      
      - name: Install dependencies
        run: npm ci
      
      - name: Run linter
        run: npm run lint
      
      - name: Run tests
        run: npm test
      
      - name: Run e2e tests
        run: npm run test:e2e

  build-and-push:
    name: Build and Push Docker Image
    runs-on: ubuntu-latest
    needs: test
    if: github.event_name == 'push' && (github.ref == 'refs/heads/main' || github.ref == 'refs/heads/master')
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3
      
      - name: Login to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ env.DOCKER_USERNAME }}
          password: ${{ secrets.DOCKER_HUB_TOKEN }}
      
      - name: Extract metadata (tags, labels) for Docker
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.DOCKER_USERNAME }}/${{ env.IMAGE_NAME }}
          tags: |
            type=ref,event=branch
            type=ref,event=pr
            type=semver,pattern={{version}}
            type=semver,pattern={{major}}.{{minor}}
            type=sha,prefix={{branch}}-
            type=raw,value=latest,enable={{is_default_branch}}
      
      - name: Build and push Docker image
        uses: docker/build-push-action@v5
        with:
          context: .
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: type=registry,ref=${{ env.DOCKER_USERNAME }}/${{ env.IMAGE_NAME }}:buildcache
          cache-to: type=registry,ref=${{ env.DOCKER_USERNAME }}/${{ env.IMAGE_NAME }}:buildcache,mode=max
          no-cache: false  # Allow cache for faster builds, but code changes will trigger rebuild

  deploy:
    name: Deploy to EC2
    runs-on: ubuntu-latest
    needs: build-and-push
    if: github.event_name == 'push' && (github.ref == 'refs/heads/main' || github.ref == 'refs/heads/master')
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Setup SSH
        uses: webfactory/ssh-agent@v0.9.0
        with:
          ssh-private-key: ${{ secrets.ec2_ssh_key }}
        continue-on-error: true
        if: always()  # Always try to setup SSH, even if previous steps fail
      
      - name: Add EC2 to known hosts
        continue-on-error: true
        run: |
          mkdir -p ~/.ssh
          chmod 700 ~/.ssh
          ssh-keyscan -H ${{ secrets.ec2_host }} >> ~/.ssh/known_hosts 2>&1 || echo "Note: Could not add host key (this is OK, StrictHostKeyChecking=no will be used)"
          chmod 600 ~/.ssh/known_hosts 2>/dev/null || true
      
      - name: Test SSH connection
        continue-on-error: true
        run: |
          echo "üîç Testing SSH connection to EC2..."
          if ssh -o StrictHostKeyChecking=no -o ConnectTimeout=10 -o BatchMode=yes ${{ secrets.ec2_user }}@${{ secrets.ec2_host }} 'echo "SSH connection successful"' 2>&1; then
            echo "‚úÖ SSH connection successful!"
          else
            echo "‚ö†Ô∏è  SSH connection failed - this will prevent automatic deployment"
            echo "üìã To fix this:"
            echo "   1. Go to EC2 Console ‚Üí Your instance ‚Üí Security tab"
            echo "   2. Click on the security group"
            echo "   3. Edit inbound rules"
            echo "   4. Add/verify SSH (port 22) rule with Source: 0.0.0.0/0"
            echo "   5. Save rules"
            echo ""
            echo "üí° Until SSH is fixed, you can deploy manually using:"
            echo "   ./deploy-to-ec2.sh"
            echo ""
            echo "‚ö†Ô∏è  Skipping automatic deployment due to SSH failure"
            exit 1
          fi
      
      - name: Deploy to EC2
        if: success() || failure()  # Only run if previous step didn't explicitly fail
        env:
          EC2_HOST: ${{ secrets.ec2_host }}
          EC2_USER: ${{ secrets.ec2_user }}
          DOCKER_HUB_TOKEN: ${{ secrets.DOCKER_HUB_TOKEN }}
          DOCKER_USERNAME: ${{ env.DOCKER_USERNAME }}
          IMAGE_NAME: ${{ env.DOCKER_USERNAME }}/${{ env.IMAGE_NAME }}:master
          CONTAINER_NAME: back-service
          PORT: 3000
        run: |
          echo "üöÄ Starting deployment..."
          ssh -o StrictHostKeyChecking=no -o ConnectTimeout=30 ${{ secrets.ec2_user }}@${{ secrets.ec2_host }} \
            DOCKER_HUB_TOKEN="$DOCKER_HUB_TOKEN" \
            DOCKER_USERNAME="$DOCKER_USERNAME" \
            IMAGE_NAME="$IMAGE_NAME" \
            CONTAINER_NAME="$CONTAINER_NAME" \
            PORT="$PORT" \
            EC2_HOST="$EC2_HOST" \
            bash -s << 'DEPLOY_SCRIPT'
            set -e
            
            echo "üîê Logging into Docker Hub..."
            echo "$DOCKER_HUB_TOKEN" | docker login -u "$DOCKER_USERNAME" --password-stdin > /dev/null 2>&1 || {
              echo "‚ùå Docker Hub login failed"
              exit 1
            }
            
            echo "üì• Pulling latest image (forcing fresh pull)..."
            # Wait longer to ensure image is fully available in registry after build
            echo "‚è≥ Waiting for image to be available in registry (this can take up to 30 seconds)..."
            sleep 15
            
            # Remove local image to force fresh pull from registry
            docker rmi "$IMAGE_NAME" 2>/dev/null || true
            
            # Retry pulling image (sometimes registry needs a moment)
            MAX_RETRIES=3
            RETRY_COUNT=0
            while [ $RETRY_COUNT -lt $MAX_RETRIES ]; do
              if docker pull "$IMAGE_NAME"; then
                echo "‚úÖ Image pulled successfully"
                break
              else
                RETRY_COUNT=$((RETRY_COUNT + 1))
                if [ $RETRY_COUNT -lt $MAX_RETRIES ]; then
                  echo "‚ö†Ô∏è  Pull failed, retrying in 5 seconds... (attempt $RETRY_COUNT/$MAX_RETRIES)"
                  sleep 5
                else
                  echo "‚ùå Failed to pull image after $MAX_RETRIES attempts"
                  exit 1
                fi
              fi
            done
            
            # Verify we have the latest image
            echo "üìã Image details:"
            docker images "$IMAGE_NAME" --format "{{.ID}} {{.CreatedAt}} {{.Repository}}:{{.Tag}}"
            
            # Get the image digest to verify it's the latest
            IMAGE_DIGEST=$(docker inspect "$IMAGE_NAME" --format "{{.RepoDigests}}" 2>/dev/null || echo "unknown")
            echo "üîç Image digest: $IMAGE_DIGEST"
            
            echo "üõë Stopping existing container..."
            # Force stop and remove ALL containers with this name (in case of duplicates)
            docker ps -a --filter "name=$CONTAINER_NAME" --format "{{.ID}}" | while read id; do
              if [ ! -z "$id" ]; then
                echo "Stopping and removing container $id..."
                docker stop "$id" 2>/dev/null || true
                docker rm -f "$id" 2>/dev/null || true
              fi
            done
            
            # Also stop any containers using port 3000
            docker ps --format "{{.ID}}" --filter "publish=3000" | while read id; do
              if [ ! -z "$id" ]; then
                echo "Stopping container $id using port 3000..."
                docker stop "$id" 2>/dev/null || true
                docker rm -f "$id" 2>/dev/null || true
              fi
            done
            
            # Wait a moment for ports to be released
            sleep 3
            
            # Get the image ID we just pulled to ensure we use it
            LATEST_IMAGE_ID=$(docker images "$IMAGE_NAME" --format "{{.ID}}" | head -1)
            LATEST_IMAGE_CREATED=$(docker images "$IMAGE_NAME" --format "{{.CreatedAt}}" | head -1)
            echo "üì¶ Latest image details:"
            echo "   Image ID: $LATEST_IMAGE_ID"
            echo "   Created: $LATEST_IMAGE_CREATED"
            
            echo "‚ú® Starting new container with latest image..."
            docker run -d \
              --name "$CONTAINER_NAME" \
              --restart unless-stopped \
              -p "$PORT:3000" \
              "$IMAGE_NAME" || {
              echo "‚ùå Failed to start container"
              exit 1
            }
            
            echo "‚è≥ Waiting for container to start..."
            sleep 8
            
            echo "üìä Container status:"
            docker ps | grep "$CONTAINER_NAME" || {
              echo "‚ö†Ô∏è  Container not found in running containers"
              echo "üìã Recent logs:"
              docker logs --tail 20 "$CONTAINER_NAME" 2>&1 || true
              exit 1
            }
            
            # Verify the container is using the latest image
            CONTAINER_IMAGE_ID=$(docker inspect "$CONTAINER_NAME" --format "{{.Image}}" | cut -d: -f2 | cut -c1-12)
            LATEST_IMAGE_ID_SHORT=$(echo "$LATEST_IMAGE_ID" | cut -c1-12)
            echo "üîç Verifying container is using latest image..."
            echo "   Container image: $CONTAINER_IMAGE_ID"
            echo "   Latest image: $LATEST_IMAGE_ID_SHORT"
            
            if [ "$CONTAINER_IMAGE_ID" != "$LATEST_IMAGE_ID_SHORT" ]; then
              echo "‚ö†Ô∏è  WARNING: Container is not using the latest image!"
              echo "   Forcing restart with latest image..."
              docker stop "$CONTAINER_NAME" 2>/dev/null || true
              docker rm -f "$CONTAINER_NAME" 2>/dev/null || true
              sleep 3
              docker run -d \
                --name "$CONTAINER_NAME" \
                --restart unless-stopped \
                -p "$PORT:3000" \
                "$IMAGE_NAME"
              sleep 8
            else
              echo "‚úÖ Container is using the latest image!"
            fi
            
            echo ""
            echo "üìã Container logs (last 10 lines):"
            docker logs --tail 10 "$CONTAINER_NAME"
            
            # Verify the deployed version
            echo ""
            echo "üîç Verifying deployed version..."
            sleep 3
            DEPLOYED_VERSION=$(curl -s "http://localhost:$PORT/api-json" 2>/dev/null | grep -o '"version":"[^"]*"' | cut -d'"' -f4 || echo "unknown")
            echo "üìå Deployed version: $DEPLOYED_VERSION"
            
            if [ "$DEPLOYED_VERSION" = "unknown" ]; then
              echo "‚ö†Ô∏è  Could not verify version from API (app might still be starting)"
            fi
            
            echo ""
            echo "‚úÖ Deployment successful!"
            echo "üåê Application available at: http://$EC2_HOST:$PORT"
          DEPLOY_SCRIPT
      
      - name: Verify deployment
        continue-on-error: true
        run: |
          echo "‚è≥ Waiting for application to start..."
          sleep 10
          echo "üîç Checking if application is accessible..."
          curl -f --max-time 5 http://${{ secrets.ec2_host }}:3000 && echo "‚úÖ Application is accessible!" || echo "‚ö†Ô∏è  Health check failed - this may be due to security group settings. Check that port 3000 is open."

