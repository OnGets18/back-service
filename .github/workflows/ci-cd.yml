name: CI/CD Pipeline

on:
  push:
    branches: [ main, master ]
  pull_request:
    branches: [ main, master ]

env:
  DOCKER_USERNAME: ongets18
  IMAGE_NAME: back-service

jobs:
  test:
    name: Run Tests
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '24'
          cache: 'npm'
      
      - name: Install dependencies
        run: npm ci
      
      - name: Run linter
        run: npm run lint
      
      - name: Run tests
        run: npm test
      
      - name: Run e2e tests
        run: npm run test:e2e

  build-and-push:
    name: Build and Push Docker Image
    runs-on: ubuntu-latest
    needs: test
    if: github.event_name == 'push' && (github.ref == 'refs/heads/main' || github.ref == 'refs/heads/master')
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3
      
      - name: Login to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ env.DOCKER_USERNAME }}
          password: ${{ secrets.DOCKER_HUB_TOKEN }}
      
      - name: Extract metadata (tags, labels) for Docker
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.DOCKER_USERNAME }}/${{ env.IMAGE_NAME }}
          tags: |
            type=ref,event=branch
            type=ref,event=pr
            type=semver,pattern={{version}}
            type=semver,pattern={{major}}.{{minor}}
            type=sha,prefix={{branch}}-
            type=raw,value=latest,enable={{is_default_branch}}
      
      - name: Build and push Docker image
        uses: docker/build-push-action@v5
        with:
          context: .
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: type=registry,ref=${{ env.DOCKER_USERNAME }}/${{ env.IMAGE_NAME }}:buildcache
          cache-to: type=registry,ref=${{ env.DOCKER_USERNAME }}/${{ env.IMAGE_NAME }}:buildcache,mode=max

  deploy:
    name: Deploy to EC2
    runs-on: ubuntu-latest
    needs: build-and-push
    if: github.event_name == 'push' && (github.ref == 'refs/heads/main' || github.ref == 'refs/heads/master')
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Setup SSH
        uses: webfactory/ssh-agent@v0.9.0
        with:
          ssh-private-key: ${{ secrets.ec2_ssh_key }}
        continue-on-error: true
        if: always()  # Always try to setup SSH, even if previous steps fail
      
      - name: Add EC2 to known hosts
        continue-on-error: true
        run: |
          mkdir -p ~/.ssh
          chmod 700 ~/.ssh
          ssh-keyscan -H ${{ secrets.ec2_host }} >> ~/.ssh/known_hosts 2>&1 || echo "Note: Could not add host key (this is OK, StrictHostKeyChecking=no will be used)"
          chmod 600 ~/.ssh/known_hosts 2>/dev/null || true
      
      - name: Test SSH connection
        continue-on-error: true
        run: |
          echo "üîç Testing SSH connection to EC2..."
          if ssh -o StrictHostKeyChecking=no -o ConnectTimeout=10 -o BatchMode=yes ${{ secrets.ec2_user }}@${{ secrets.ec2_host }} 'echo "SSH connection successful"' 2>&1; then
            echo "‚úÖ SSH connection successful!"
          else
            echo "‚ö†Ô∏è  SSH connection failed - this will prevent automatic deployment"
            echo "üìã To fix this:"
            echo "   1. Go to EC2 Console ‚Üí Your instance ‚Üí Security tab"
            echo "   2. Click on the security group"
            echo "   3. Edit inbound rules"
            echo "   4. Add/verify SSH (port 22) rule with Source: 0.0.0.0/0"
            echo "   5. Save rules"
            echo ""
            echo "üí° Until SSH is fixed, you can deploy manually using:"
            echo "   ./deploy-to-ec2.sh"
            echo ""
            echo "‚ö†Ô∏è  Skipping automatic deployment due to SSH failure"
            exit 1
          fi
      
      - name: Deploy to EC2
        if: success() || failure()  # Only run if previous step didn't explicitly fail
        env:
          EC2_HOST: ${{ secrets.ec2_host }}
          EC2_USER: ${{ secrets.ec2_user }}
          DOCKER_HUB_TOKEN: ${{ secrets.DOCKER_HUB_TOKEN }}
          DOCKER_USERNAME: ${{ env.DOCKER_USERNAME }}
          IMAGE_NAME: ${{ env.DOCKER_USERNAME }}/${{ env.IMAGE_NAME }}:master
          CONTAINER_NAME: back-service
          PORT: 3000
        run: |
          echo "üöÄ Starting deployment..."
          ssh -o StrictHostKeyChecking=no -o ConnectTimeout=30 ${{ secrets.ec2_user }}@${{ secrets.ec2_host }} \
            DOCKER_HUB_TOKEN="$DOCKER_HUB_TOKEN" \
            DOCKER_USERNAME="$DOCKER_USERNAME" \
            IMAGE_NAME="$IMAGE_NAME" \
            CONTAINER_NAME="$CONTAINER_NAME" \
            PORT="$PORT" \
            EC2_HOST="$EC2_HOST" \
            bash -s << 'DEPLOY_SCRIPT'
            set -e
            
            echo "üîê Logging into Docker Hub..."
            echo "$DOCKER_HUB_TOKEN" | docker login -u "$DOCKER_USERNAME" --password-stdin > /dev/null 2>&1 || {
              echo "‚ùå Docker Hub login failed"
              exit 1
            }
            
            echo "üì• Pulling latest image (forcing fresh pull)..."
            # Remove local image to force fresh pull from registry
            docker rmi "$IMAGE_NAME" 2>/dev/null || true
            # Pull latest image from registry (no cache)
            docker pull "$IMAGE_NAME" || {
              echo "‚ùå Failed to pull image"
              exit 1
            }
            echo "‚úÖ Image pulled successfully"
            # Verify we have the latest image
            echo "üìã Image details:"
            docker images "$IMAGE_NAME" --format "{{.ID}} {{.CreatedAt}}"
            
            echo "üõë Stopping existing container..."
            # Force stop and remove container by name
            docker stop "$CONTAINER_NAME" 2>/dev/null || true
            docker rm -f "$CONTAINER_NAME" 2>/dev/null || true
            # Also stop any containers using port 3000
            docker ps --format "{{.ID}}" --filter "publish=3000" | while read id; do
              if [ ! -z "$id" ]; then
                echo "Stopping container $id using port 3000..."
                docker stop "$id" 2>/dev/null || true
                docker rm -f "$id" 2>/dev/null || true
              fi
            done
            # Wait a moment for ports to be released
            sleep 2
            # Remove old image to ensure we use the latest
            echo "üßπ Cleaning up old images..."
            docker image prune -f > /dev/null 2>&1 || true
            
            echo "‚ú® Starting new container..."
            docker run -d \
              --name "$CONTAINER_NAME" \
              --restart unless-stopped \
              -p "$PORT:3000" \
              "$IMAGE_NAME" || {
              echo "‚ùå Failed to start container"
              exit 1
            }
            
            echo "‚è≥ Waiting for container to start..."
            sleep 5
            
            echo "üìä Container status:"
            docker ps | grep "$CONTAINER_NAME" || {
              echo "‚ö†Ô∏è  Container not found in running containers"
              echo "üìã Recent logs:"
              docker logs --tail 20 "$CONTAINER_NAME" 2>&1 || true
              exit 1
            }
            
            echo ""
            echo "üìã Container logs (last 10 lines):"
            docker logs --tail 10 "$CONTAINER_NAME"
            
            echo ""
            echo "‚úÖ Deployment successful!"
            echo "üåê Application available at: http://$EC2_HOST:$PORT"
          DEPLOY_SCRIPT
      
      - name: Verify deployment
        continue-on-error: true
        run: |
          echo "‚è≥ Waiting for application to start..."
          sleep 10
          echo "üîç Checking if application is accessible..."
          curl -f --max-time 5 http://${{ secrets.ec2_host }}:3000 && echo "‚úÖ Application is accessible!" || echo "‚ö†Ô∏è  Health check failed - this may be due to security group settings. Check that port 3000 is open."

